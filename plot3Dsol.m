% [Xc Yc Zc] = plot3Dsol(VARS,ZEES,EDGES) both plots the instanteous 
% contact patch and returns a square matrix of the x, y and z values
% suitable for plotting, or calculating the area via ToolContactArea.m
%
% VARS is a 1x9 matrix, where VARS=[Rm to tf Rr R a b P Rstar], with the 
% first 8 values describing the geometry, and the last value describing the
% resolution and size of Xc, Yc and Zc. 
%
% ZEES is generated by plot2Dsol, where ZEES=[z12 z13 zl zu].
%
% If EDGES is true, then edges will be shown on roller outline primaries.
% Eq. and Table numbers refer to identifiers in original publication
%
% Companion subfunction to AFFC.m
% M.J. Roy, 2016
function [X_ToolContact,Y_ToolContact,Z_ToolContact]= plot3Dsol(vars,zees,Ed)

Rm=vars(1);
to=vars(2);
tf=vars(3);
Rr=vars(4);
R=vars(5);
a=vars(6);
b=vars(7);
P=vars(8);
Rstar=vars(9);
z12=zees(1);
z13=zees(2);
zl=zees(3);
zu=zees(4);

Ri=Rm+to;
d=Rm+tf+R+Rr;
phi=Rr+R/cosd(a);

Xmax=(d^2-(Rr+R)^2+Ri^2)/(2*d); % Eq. 15
Ymax=sqrt(4*d^2*Ri^2-(d^2-(Rr+R)^2+Ri^2)^2)/(2*d); %Eq. 16

tmax=atan(Ymax/Xmax); %Eq. 14

tf=tmax;

res=Rstar;

Z=linspace(z13,z12,Rstar); % Eq. 17
Y=linspace(0,Ri*sin(tf),Rstar); % Eq. 18
T=linspace(0,tf,Rstar); % Eq. 19



%the matrix shown in eq. 25 is built using vars j and k

%instantaneous roller position surfaces, Equation 26-28
for j=1:res %%z
     for k=1:res %%t
        z=Z(j);
        t=T(k);

        y=Ri*sin(T(k));
        %% Upper flat
        if z>zu
            X_Tool(j,k)=d+(R*(cosd(b)-cosd(a)))/(cosd(a)*cosd(b))-...
                (phi-z*tand(b))*sqrt(1-(Ri^2*(sin(t))^2)/phi^2); %Eq. 20, first case

            Y_Tool(j,k)=y; %Eq. 21
            Z_Tool(j,k)=z; %Eq. 22


        else
            %% Lower flat
            if z<=zl
                X_Tool(j,k)=d-(phi+z*tand(a))*sqrt...
                    (1-(Ri^2*(sin(t))^2)/phi^2); %Eq. 20, second case
                Y_Tool(j,k)=y; %Eq. 21
                Z_Tool(j,k)=z; %Eq. 22

            else %% Radiused sector
                X_Tool(j,k)=d-sqrt((sqrt(R^2-z^2)+Rr)^2-...
                    y^2); %Eq. 20, final case
                Y_Tool(j,k)=y; %Eq. 21
                Z_Tool(j,k)=z; %Eq. 22
            end
            
        end
     end
end


%mandrel/material surface
for j=1:res %%z
     for k=1:res %%t
        z=Z(j);
        t=T(k);%Tcoord(j)
        X_Mandrel_M(j,k)=Ri*cos(t); %Eq. 23
        Y_Mandrel_M(j,k)=Ri*sin(t); %Eq. 24
        Z_Mandrel_M(j,k)=z;			%Eq. 25

     end
end


%previous toolpath, Equation 32-35
for j=1:res %%z
     for k=1:res %%t
        t=T(k);%Tcoord(j)
        z=Z(j);
        y=Y(k);
        if z>zu+P %%Upper flat
            fprintf('Entered . . .\n')
            if ~RamOn
            S=d+R*(cosd(b)-cosd(a))/(cosd(a)*cosd(b))-((phi/tand(b)-z+...
                P*(1-t/(2*pi)))*tand(b)*R)/phi; %Eq. 26, first case
                fprintf('Used original Scond\n');
            else
             S=d+R*(cosd(b)-cosd(a))/(cosd(a)*cosd(b))-((phi/tand(b)-z+...
                P*(1-t/(2*pi)))*tand(b)); %Eq. 26, first case
            end
            X_ToolPath(j,k)=S*cos(t); %Eq. 27
            Y_ToolPath(j,k)=S*sin(t); %Eq. 28
            Z_ToolPath(j,k)=z;
        else
            if z<zl+P %%Lower flat
                S=d+(-phi/tand(a)-z+...
                P*(1-t/(2*pi)))*tand(a); 	%Eq. 26, second case
                X_ToolPath(j,k)=S*cos(t); 	%Eq. 27
                Y_ToolPath(j,k)=S*sin(t);	%Eq. 28
                Z_ToolPath(j,k)=z;			%Eq. 29

            else %% Radiused section
                  S=(d-Rr)-sqrt(R^2-(z-(P-P*t/(2*pi)))^2); %Eq. 26, final case
                  X_ToolPath(j,k)=S*cos(t);					%Eq. 27
                  Y_ToolPath(j,k)=S*sin(t);					%Eq. 28
                  Z_ToolPath(j,k)=z;						%Eq. 29

            end

        end
     end
end

%%%%%%%%%%%%%%%% For Tool Contact %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Samples each point of the constraining surfaces.  Uses a comparison
%% between the tool point, the mandrel point and the previous tool path
%% point at each node.
for m=1:res %across
    for n=1:res %down
        testM=[X_Mandrel_M(m,n) Y_Mandrel_M(m,n) Z_Mandrel_M(m,n)];
        testTP=[X_ToolPath(m,n) Y_ToolPath(m,n) Z_ToolPath(m,n)];
        testT=[X_Tool(m,n) Y_Tool(m,n) Z_Tool(m,n)];

        %Test x coordinate (less than the mandrel and less than the
        %toolpath)
        if testT(1,1)<=testM(1,1) && testT(1,1)<=testTP(1,1) %Eq. 30
            xgood=true;
        else xgood=false;
        end
        %Test y coordinate (less than the mandrel OR less than the
        %toolpath)
        if testT(1,2)<=testM(1,2) || testT(1,2)<=testTP(1,2) %Eq. 31
            ygood=true;
        else ygood=false;
        end
        %Test z coordinate (less than the toolpath) %Eq. 32
        if testT(1,3)<=testTP(1,3)
            zgood=true;
        else zgood=false;
        end
        % If x,y,z all good, then the tool point is in the solution set and
        % write them to a new surface matrix.  If not, then write a NaN
        % value to the contact matrix at that location.  NaN's correspond
        % to values not in solution space.
        if xgood==true && ygood==true && zgood==true
            X_ToolContact(m,n)=X_Tool(m,n); 
            Y_ToolContact(m,n)=Y_Tool(m,n);
            Z_ToolContact(m,n)=Z_Tool(m,n);
        else
            X_ToolContact(m,n)=NaN;
            Y_ToolContact(m,n)=NaN;
            Z_ToolContact(m,n)=NaN;
        end

    end
end
% Snippet added to output independent points to a csv file in the form of
% x, y, z. Toggled by changing csvout true or false

colormap bone
surf(X_ToolContact,Y_ToolContact,Z_ToolContact)
axis tight
axis equal
grid on
box on
if ~Ed
shading interp
end
    xlabel('x','interpreter','none','fontsize',13);
    ylabel('y','interpreter','none','fontsize',13);
    zlabel('z','interpreter','none','fontsize',13);